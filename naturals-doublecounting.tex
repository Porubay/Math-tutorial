\section{Двойной счёт}

Напомню, что в графе степенью вершины $\deg(v)$ мы назвали количество рёбер, ей инцидентных.

\begin{thm}
Пусть $V$~--- множество вершин некоторого графа, $e$~--- количество его рёбер. Тогда
$$\sum_{v\in V}\deg(v) = 2e$$
\end{thm}
\begin{proof}
Мы можем пересчитать все рёбра графа двумя способами: собственно, пересчитывая сами рёбра (получим в этом случае $e$), либо же пересчитывая вершины и складывая степени $\deg{v}$. В этом случае, правда, получится, что каждое ребро мы учтём два раза, поскольку каждое ребро инцидентно ровно двум вершинам.
\end{proof}

Это элементарное доказательство является простейшим примером доказательства методом \term{двойного счёта}. Приём этот выглядит всегда одинаково: мы берём некоторый набор объектов и считаем его двумя разными способами, получая в итоге одно и то же значение, но записанное в разном виде. По большому счёту рекурсивные формулы для вычисления числа сочетаний, чисел Белла и чисел Стирлинга, а так же формулы их сумм, доказывались нами именно методом двойного счёта, только мы не произносили этого слова. Остаток этого параграфа мы посвятим разбору ещё нескольких подобных примеров.

\begin{thm}
$$\sum_{k=0}^m {m\choose k}{w\choose n-k} = {m+w\choose n}$$
\end{thm}
\begin{proof}
Пусть у нас имеется $m$ мужчин и $w$ женщин. Нам надо выбрать из них группу $n$ человек. Очевидно, что это можно сделать $m+w\choose n$ способами. С другой стороны, мы можем отдельно рассмотреть все варианты, когда мы выбираем $k$ мужчин и $n-k$ женщин, что даёт нам левую часть.
\end{proof}

\begin{corollary}
$$\sum_{k=0}^n{n\choose k}^2 = {2n\choose n}$$
\end{corollary}
\begin{proof}
Достаточно положить $m=w=n$ и заметить, что ${n\choose k}={n\choose n-k}$.
\end{proof}

\begin{thm}
$$\sum_{k=q}^n{n\choose k}{k\choose q} = 2^{n-q}{n\choose q}$$
\end{thm}
\begin{proof}
Левую часть можно интерпретировать как количество способов выбрать различные подмножества $[n]$ с по крайней мере $q$ элементами, и затем в этих множествах выделить ещё некоторые $q$ элементов. Правая часть даёт ровно ту же самую величину, но в этом случае мы вначале выбираем $q$ помеченных элементов из $[n]$, а затем добавляем к полученному набору один из $2^{n-q}$ подмножеств, составленных из оставшихся элементов.
\end{proof}

\begin{thm}
$$k!\sstirling{n}{k} = k^n - {k \choose 1}(k-1)^n + {k\choose 2}(k-2)^n -\ldots$$
\end{thm}
\begin{proof}
Справа, как мы увидели в конце прошлого параграфа, перечислено количество сюръекций $[n]\to[k]$. Однако, их можно перечислить и по-другому. Пусть $f$~--- некоторая сюръекция, тогда прообразы $f^{-1}(1)$, $f^{-1}(2)$,~... не пусты и задают некоторое разбиение множества $[n]$ на $k$ подмножеств. Таких разбиений существует $\sstirling{n}{k}$ штук. В то же время если $\rho$~--- некоторая перестановка на $[k]$, то $\rho\circ f$ так же задаёт то же самое разбиение множества $[n]$, хотя сюръекция уже будет другой. Поскольку мы имеем $k!$ таких перестановок $[k]$, общее количество сюръекций может быть так же определено как $k!\sstirling{n}{k}$.
\end{proof}

\begin{definition}
Граф называется \term{связным}, если в нём существует путь между любыми двумя вершинами.
\end{definition}

\begin{definition}
\term{Деревом} называется связный граф без циклов.
\end{definition}

Деревья часто применяются в компьютерных системных поиска. Самый распространённый вариант~--- это двоичные деревья поиска, которые представляют собой следующую структуру: каждая вершина дерева обладает некоторым значением и, возможно, тремя гранями, называемых ветвями. Одна ветвь ведёт в направлении корня, другая ветвь, называемая левой, ведёт ко всем вершинам со значениями, меньшими чем текущее, а вторая ветвь, называемая правой, ведёт к большим значениям. Если предположить, что значения~--- это строки, то их порядок может восприниматься как алфавитный. Пример такого бинарного дерева поиска представлен на рисунке 3.11.

\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
  arn_n/.style = {treenode, rectangle, black, font=\sffamily\bfseries, draw=white,
    fill=white},% arbre rouge noir, noeud noir
}

\begin{figure}[h]
\centering
\begin{tikzpicture}[->,level/.style={sibling distance = 5cm/#1,
  level distance = 1.5cm}] 
\node [arn_n] {Николай}
    child{ node [arn_n] {Евгения} 
            child{ node [arn_n] {Авдотья}}
            child{ node [arn_n] {Жанна}}                            
    }
    child{ node [arn_n] {Роман}
            child{ node [arn_n] {Ольга}}
            child{ node [arn_n] {Света}}
    }
; 
\end{tikzpicture}
\caption{Бинарное дерево поиска}
\end{figure}

Предположим, что в дереве на рисунке 3.11 так же в каждом узле дерева записан телефон, и что мы захотели найти телефон Ольги. Если бы мы просматривали все телефоны подряд, то в случае их упорядоченности по алфавиту, прежде чем мы наткнулись бы на Олин телефон, нам пришлось бы проверить шесть записей. Однако, вместо этого мы могли бы искать телефон в дереве, двигаясь от корня: вначале мы увидели бы, что имя Ольга должно идти после имени Николай, что значит, что мы должны искать по правой ветви от корня, где мы встречаем имя Роман. Ольга идёт раньше Романа по алфавиту, поэтому мы продолжаем искать её в левой ветви, где и находим её телефон. Итого нам потребовалось три шага поиска: вдвое быстрее чем при последовательном переборе.

\begin{exercise}
Пусть мы ищем телефон Фиофанта. Покажите, что при последовательном поиске нам потребовалось бы 7 шагов, чтобы убедиться, что такого телефона нет, а при поиске  в дереве всего 3 шага.
\end{exercise}

\begin{exercise}
Пусть у нас теперь имеется дерево, в котором записано 2147483647 телефонных номеров. Например, это может база данных ФСБ или ещё какая. Покажите, что используя бинарное дерево поиска, мы можем найти любой телефон (или убедиться, что его нет в базе) максимум за 31 шаг.
\end{exercise}

Последнее упражнение показывает, что использование деревьев может здорово упростить поиск информации (зачастую ускорение получается в миллионы раз). Собственно очень похожим образом устроены почти все базы данных, и без деревьев не было бы ни компании Гугл, ни, наверное, вообще компьютерной техники в современном её виде. Чтобы уметь анализировать скорость работы алгоритмов, нам прежде всего необходимо уметь пересчитывать все деревья.

Бинарные деревья~--- это в общем-то частный случай дерева. Как перечислить все возможные деревья поиска мы поймём позже в нашем курсе (мы изучим общие подходы), а пока что же мы перечислим  просто все возможные деревья с $n$ вершинами. При изучении следующего доказательства важно иметь ввиду следующие уточнения постановки задачи, которые мы подразумеваем:
\begin{enumerate}
\item Дерево не обладает корнем; все вершины равнозначны;
\item Вершины деревьев имеют определённые метки (данные), то есть даже если два дерева имеют одинаковую форму внешне, но вершины имеют разные именования, мы рассматриваем эти деревья как различные;
\item Каждая вершина может иметь произвольное количество инцидентных рёбер.
\end{enumerate}

Если изменить любое из этих условий, то формула для количества деревьев будет уже совершенно другой, но пока мы не будем рассматривать эти случаи.

\begin{table}[h]
\centering
\begin{tabular}{c|ccccc}
$x$ & 1 & 2 & 3 & 4 & 5 \\
\hline
$f(x)$ & 4 & 1 & 1 & 2 & 4
\end{tabular}
\caption{Пример функции $f$}
\end{table}

\begin{thm}
Существует $n^{n-2}$ деревьев с $n$ вершинами.
\end{thm}
\begin{proof}
Подсчитаем количество функций $f:[n]\to[n]$ двумя способами. С одной стороны количество таких функций $n^n$, это тривиальная теорема, рассмотренная нами в~\S~3.1. Попробуем теперь подсчитать количество функций $f$, сопоставив каждой функции некоторое дерево. Это довольно сложное рассуждение, поэтому будем рассматривать его на примере функции $f$, значения которой заданы в таблице~3.2. Пусть
$$C = \{x \in[n]| \exists k\ f^k(x) = x\}$$
то есть это множество таких элементов $x$ из $[n]$, что применяя к ним $f$ последовательно несколько раз, мы в какой-то момент получим тот же $x$. Для функции из нашего примера $C = \{1,2,4\}$.

Если упорядочить по возрастанию элементы $C$ и рассмотреть ограничение на нём $f|_C$, то эта функция будет действовать как перестановка $C$, которую мы можем записать строкой (в примере будет $f|_C = 412$). Теперь, выбрав в качестве вершин графа элементы $[n]$, мы можем соединить вершины из $C$ в порядке, заданном перестановкой. Элементы $[n]\backslash C$ пока правда остаются изолированными. Чтобы сформировать из них дерево, для каждого значения $x\in [n]\backslash C$, если $f(x)=y$ добавим ребро $xy$. Для функции из примера это будут рёбра 31 и 54. Получившееся дерево изображено на рисунке~3.12.

\begin{figure}[h]
\centering
\begin{tikzpicture}
\def\point{node [circle, draw, fill, inner sep = 0, minimum size = .1cm] }
\draw (0, 0) \point (p1) {};
\draw (1cm, 0cm) \point (p2) {};
\draw (0cm, 1cm) \point (p3) {};
\draw (-1cm, 0cm) \point (p4) {};
\draw (-1cm, -1cm) \point (p5) {};

\node [below] at (p1) {1};
\node [right] at (p2) {2 (конец)};
\node [left] at (p3) {3};
\node [left] at (p4) {(начало) 4};
\node [right] at (p5) {5};

\draw (p1) -- (p2);
\draw (p1) -- (p3);
\draw (p1) -- (p4);
\draw (p4) -- (p5);
\end{tikzpicture}
\caption{Дерево, построенное по функции $f$}
\end{figure}

Надо теперь показать, что и для каждого дерева мы можем задать функцию. Это делается в полной аналогии: вначале выбираем в дереве условные <<начало>> и <<конец>> (внимание!) и находим путь от начала к концу. Вершины этого пути задают множество $C$, а последовательность вершин перестановку $f|_C$. Для вершин $x$, не вошедших в этот путь, в качестве значения $f(x)$ выбираем следующую вершину по пути от $x$ до <<конца>> дерева.

Остаётся лишь заметить, что заданная конструкция даёт нам не просто дерево, а дерево с выбранными <<началом>> и <<концом>>. У дерева с $n$ вершинами есть $n^2$ способов определить начало и конец, поэтому количество произвольных деревьев в $n^2$ раз меньше, чем количество функций $[n]\to[n]$. (По-хорошему так же надо более чётко указать, что соответствие деревьев и функций в данном случае действительно однозначное, но это не сложно и я оставляю это в качестве упражнения читателю).
\end{proof}
