\section{Невычислимое, недоказуемое}

В этом параграфе мы поговорим о совсем отвлечённых темах, не упомянуть которые я не могу в силу их удивительности. Этот разговор будет совершенно не формальным, а больше ознакомительным, так как мы окунёмся совершенно в иную область математики. Материал этого параграфа не является необходимым для дальнейшего чтения учебника, так что если что-то станет совсем не понятно, его можно смело пропускать. Впрочем, если вы поймёте изложенное, то, думаю, получите от этого большое удовольствие.

Предположим, что у нас есть какое-то логическое утверждение, зависящее от натурального числа $P(n)$. Это утверждение, предположим, можно легко проверить для любого конкретного числа, но не понятно верно ли оно для любого числа.

Например, можно рассмотреть гипотезу Гольдбаха о том, что любое чётное число может быть представлено в виде суммы двух простых чисел (так, например, $50=19+31$ или $100=11+89$). Для любого конкретного чётного числа можно довольно легко перебором подобрать его разложение на сумму двух простых чисел. По крайней мере всегда у учёных это получалось. А вот возможно ли это сделать в общем случае, то если получится ли представить в виде суммы двух простых вообще любое чётное число~--- вопрос, на который наука пока не нашла ответа.

Или вот можно рассмотреть последовательности Коллатца. Начальный элемент последовательности~--- это произвольное натуральное число, которое мы обозначим как $K_0$. $K_{n+1}$ получается из $K_n$ по следующему правилу: если $K_n$ чётное, то $K_{n+1}=\frac{K_n}{2}$. Если $K_n$ нечётное, то $K_{n+1} = 3K_n  + 1$. Например, если за $K_0$ принять число 15, то мы получаем следующую последовательность:
$$15, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1$$
Как видим, последовательность пришла в единицу. До сих пор с какого бы числа люди не начинали писать последовательность Коллатца, она всегда приходит в единицу, но приходит ли она в единицу всегда, или всё же есть исключения~--- никто не знает, это открытый вопрос математики.

Интуитивно должно казаться ясным, что чтобы ответить на такие вопросы, не достаточно перебрать просто большое количество вариантов. В проблеме Гольдбаха математики перебрали уйму чисел (фактически все числа, на которые хватило вычислительных возможностей), но примера, чтобы какое-то число не раскладывалось в сумму двух простых так и не нашли. Доказывает ли это что-либо? Конечно нет, потому что чисел, которых математики не проверили, куда больше~--- их ещё целая бесконечность. Аналогичная ситуация с гипотезой Коллатца.

Так вот. Примерно 50 лет тому назад было доказано, что на самом деле для почти любого утверждения достаточно проверить лишь конечное число случаев. То есть если вплоть до некоторого номера $M$ нам не встретятся чётные числа, не представимые в виде суммы двух простых, или не встретится последовательность Коллатца, не приходящая в единицу, то такие числа нам не встретятся вовсе никогда.

\begin{thm}
Для установления истинности почти любого утверждения $P(n)$ достаточно проверить лишь истинность конечного числа утверждений $P(n)$ для $n$ от 1 до некоторого $M$.
\end{thm}
\begin{proof}
Давайте представим себя на минуточку программистами и мы хотим найти такое число $M$, что $P(M)$ окажется неверным, то есть мы ищем контрпример к нашей гипотезе.

Будем считать, что мы можем написать программу для проверки утверждения $P$ для любого конкретного номера (это предположение и составляет значение слова <<почти>> в формулировке теоремы). Тогда для поиска контрпримера мы будем перебирать все числа подряд начиная 1 и пока не найдём контрпример. Возможно, мы не найдём его никогда и программа будет работать бесконечно долго, а значит у нас есть время попить чай и поразмыслить.

Код нашей программы имеет конечную длину, обозначим её N. Если рассмотреть все возможные программы длины $N$, то среди них найдутся конечно же те, которые будут работать бесконечно долго (можно сказать, что они <<зависнут>>) и те, которые остановятся в итоге. Обозначим за $B_N$ самое долгое время работы программы длины $N$ (на английском эти числа называются Busy Beaver Numbers по фольклорным причинам, а как это адекватно переводится на русский я и не знаю). Как вычислить это самое $B_N$ не очень понятно, но такое число вполне определено. Предположим пока, что мы его знаем.

Посмотрим на часы, сколько уже работает наша программа по поиску контрпримера, пока мы пили чай? Что? Уже дольше, чем $B_N$? Но ведь $B_N$ это самое долгое время, которое может работать программа, которая останавливастся. Значит мы знаем, что программа не остановится уже никогда, то есть контрпример не будет найден. Утверждение об истинности $P$ можно считать доказанным, программу можно выключать.

Конечно же, наша программа за конечное время $B_N$ успела проверить лишь конечное число случаев от 1 до $M$, но из рассуждений, приведенных выше, следует, что нам этого каким-то образом оказалось достаточно для того, чтобы утверждать об истинности $P$ для совсем любого $n$. В чём тут подвох? Подвоха тут нет. 
\end{proof}

Задумайтесь на секундочку: почти любой сложный вопрос математики, касающийся натуральных чисел, может быть установлен путём перебора конечного числа вариантов. Будь то теорема Ферма, гипотеза Гольдбаха, Коллатца или кого ещё: достаточно проверить конечное число случаев. Не знаю как вам, но на меня в своё время этот факт произвёл неизгладимое впечатление.

Насколько этот результат практичен? На самом деле совершенно не практичен. Во-первых, не понятно как вычислить значение $B_N$. Во-вторых, даже если мы его вычислим для какого-то большого $N$, то само $B_N$ наверняка окажется настолько гигантским, что само число вряд ли поместится в наш калькулятор. Так что выгоды мы из этого всего извлечь судя по всему не можем, увы. Но сам факт!

Логично было бы, если бы после изложения этого результата я тут же показал бы, как считать числа $B_n$, однако сейчас мы уйдём в сторону и я покажу как эти числа ещё можно было бы использовать, если бы они были в нашем распоряжении.

Попробуем написать такую программу, которая будет анализировать другую программу, и говорить нам о том, зависнет она или же нормально остановится. Можно рассматривать такую программу как функцию $H:P\to\{0,1\}$, где $P$~--- множество всех возможных программ. 0 означает, что программа зависнет, 1 что остановится.

При условии, что мы можем написать программу, вычисляющую $B_n$, мы нашу задачу можем очень легко решить. Пусть нам дана программа $x$ длины $n$, для которой надо установить остановится ли она. Поскольку программа~--- это просто описание каких-то действий, мы можем заставить выполнять эти действия не компьютер, а нашу программу $H$, то есть мы как бы будем симулировать выполнение программы $x$ внутри программы $H$. Это не сложно технически, но я не буду углубляться в детали как это реализуется. Если вы знакомы с компьютерными технологиями, то наверняка слышали про интерпретаторы, виртуализацию, виртуальные машины и подобное. Это именно то, это возможно и это не особо сложно.

По ходу выполнения программы $x$, программа $H$ будет считать, как долго $x$ работает. Если вдруг окажется, что программа $x$ работает дольше, чем время $B_n$, то мы знаем, что она не закончится, и $H$ останавливает $x$, выдавая нам результат 0. Если же $x$ остановится сама раньше, то $H$ даст результат 1. Вроде всё.

А теперь давайте напишем такую программу $A$, которая так же будет принимать на вход какую-то другую программу $x$, затем будет запускать на ней программу $H$, и если $H(x)=1$, то $A$ будет зависать (например, начнёт считать все натуральные числа подряд), а если же $H(x)=0$, то она будет возвращать какой-то результат. Такую программу так же легко написать.

Попробуем понять какой результат мы получим, если на вход программе $A$ мы дадим её же саму, то есть попробуем выполнить $A(A)$. Что будет? Предположим, что $H(A)=0$, тогда программа $A$ должна завершиться, вернув результат. Но это противоречит тому, что $H(A)=0$. Из этого противоречия видно, что $H(A)\not=0$. Пусть теперь $H(A)=1$, но тогда $A$ должна зависнуть, что противоречит тому, что $H(A)=1$, а значит $H(A)\not=1$. Как так? $H$ оказывается не равно ни одному своему значению!

Это противоречие означает, что программа $H$ не может быть написана, не существует такой программы и существовать не может. Но как так, ведь мы же чётко указали, как её можно написать! Если вглядеться, то при описании работы программы $H$ мы опирались на то, что мы можем как-то вычислить числа $B_n$, но мы не показывали этого. И это единственный момент во всём рассуждении, который мы не доказывали. Значит, числа $B_n$ вычислить невозможно.

Тот факт, что есть такая функция $B$, которая вполне определена, но которую невозможно вычислить, может показаться невероятным. На самом деле если подумать, то это довольно не сложно. Из определения функции $B$ мы могли бы попробовать вычислить $B(n)$, запустив одновременно все возможные программы длины $n$, и заведя таймер, пытаясь понять, какое самое большое время работы программы. Однако с учетом того, что есть программы, которые зависают, мы никогда не узнаем, когда таймер пора выключать, хотя конечно же такой момент во времени существует. Это и есть пример того, что  невозможно вычислить.

Мы получили два результата.

\begin{thm}
Невозможно написать программу, которая бы могла по коду другой программы определить остановится ли она или зависнет.
\end{thm}
\begin{thm}
Числа $B_n$ невычислимы. Другими словами невозможно определить максимальное время, которое может работать независающая программа длины $n$.
\end{thm}

Приведённые рассуждения можно вывернуть ещё и вот под каким углом. Напишем программу $E$, которая будет проверять истинность произвольного утверждения $x$ путём последовательного перебора всех возможных доказательств (программа может начинать с коротких доказательств и постепенно переходить к более длинным, так что такая программа определённо может быть написана). Если предположить, что всё можно доказать или опровергнуть, то через какое-то время наша программа либо найдёт доказательство для $x$, либо доказательство для $\neg x$.

Используя эту программу, однако, мы опять же легко можем написать пресловутую программу $H$ проверяющую, остановится ли программа $y$ или нет. Просто вместо запуска программы $y$ и ожидания времени $B_n$ мы на этот раз будем искать доказательство остановки или зависания $y$. Поскольку мы уже знаем, что программа $H$ не может существовать, наше предположение, что программа $E$ всегда либо найдёт доказательство $x$ либо $\neg x$ так же не верно. Это значит, что существуют такие утверждения $x$, которые невозможно ни доказать ни опровергнуть. Как вы вероятно помните, это есть ни что иное как теорема Гёделя о неполноте:

\begin{thm}
Существуют утверждения, которые невозможно ни доказать ни опровергнуть.
\end{thm}

Я упомянул, что числа $B_n$ окажутся скорее всего довольно большими. Оказывается, мы можем примерно прикинуть насколько именно большими они будут.

\begin{thm}
Числа $B_n$ с ростом $n$ растут быстрее, чем любая последовательность, которую мы могли бы вычислить.
\end{thm}
\begin{proof}
Предположим, что это не так, и что существует некоторая последовательность $x_n$ такая, что мы можем её вычислить и что $B_n\le x_n$. Но тогда мы можем запустить все программы длины $n$ и останавливать их как только они отработают время $x_n$. Среди программ, остановившихся раньше, выберем ту, что работала дольше. Время, которое она работала~--- это и есть $B_n$. Но это значит, что мы смогли их вычислить, а это противоречит теореме 3.51. Значит, такой последовательности $x_n$ всё же не существует.
\end{proof}