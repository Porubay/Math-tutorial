\section{Невычислимое, недоказуемое}

Я как-то раз имел разговор с гражданином десяти лет от роду. Не помню зачем, но я пытался объяснить ему коммутативность умножения натуральных чисел. Он отлично знал, что <<$ab=ba$>>, потому что ему это уже рассказали в школе, но я его спросил: <<А слабо доказать?>>

Он начал пытаться мне объяснять:\\
--- Ну вот видишь, $2\times 5 = 5\times 2$, $3\times 4 = 4\times 3$, $7\times 9=9\times 7$>>. Значит, это свойство выполняется.\\
--- Не понятно с чего это свойство выполняется. Ты привёл всего три примера и устверждаешь, что это всегда так, а я вижу лишь три случая, когда оно работает, в других случаях может быть и не работает.\\
--- Можно ещё рассмотреть примеры. $5\times 7=7\times 5$...\\
--- Нет-нет, а что если мы возьмём какие-то большие числа?\\
--- $11\times12 = 12\times 11$, $13\times14=14\times 13$...\\
--- Я имел ввижу если взять числа типа $123456\times 976245173$, ты уверен, что в этом случае это свойство будет выполняться?

Я пытался подвести его к мысли, что перебрать много разных значений --- это не значит доказать что-то. В итоге я показал ему, что площадь прямоугольника можно посчитать в разном порядке, но из картинки видно, что результат будет один и тот же в обоих случаях, а это и доказывает свойство коммутативности.

Он сказал, что он меня понял, но я в этом не уверен, слишком уж много в его взгляде было сомнения. Скорее я добился того, что он признал мой авторитет, нежели то что его доказательство было не верно.

Вряд ли его непонимание вызвано тем, что он какой-то неумный или что в школе плохо учат. Скорее дело в том, что по природе человеческий мозг склонен к быстрым обобщениям, которые полезны на практике, но не заточен под научные доказательства. Человеку достаточно пару раз обжечься об открытое пламя (или даже один раз), чтобы понять, что огонь~--- это горячо и трогать его не надо. Биологическому организму не требуется строго доказывать, что любой огонь опасен. Северному человеку достаточно схватить пару раз солнечный удар где-нибудь на Кипре, чтобы в дальнейшем всегда перед выходом из дома использовать противозагарный крем и панаму. Ему не надо доказывать себе в уме, что солце всегда такое ужасное, и даже в общем-то будет неоправданным лазить каждый день на сайт с погодой, чтобы выяснять уровень ультрафиолета в своём городе именно сегодня.

Одна из задач школы --- отучить человека от примитивно-биологического мышления и привить ему навык требовать в каждом случае более веских доказательств, нежели простое обощение. Такое мышление необходимо, когда человек начинает рассуждать о политике, экономике, планировании семьи или просто если он занят в какой-то более-менее интеллектуальной сфере. Принцип математической индукции~--- это как раз важнейший шаг для ребёнка к формальному и критическому мышлению и уходе от обощений. Нам не достаточно доказать истинность утверждения для случаев 1, 2, 3, 4, 5 и так далее, над надо доказать истинность лишь для 1, а затем доказать следствие $n+1$ из $n$.

Обобщения не то чтобы всегда не верны. С точки зрения статистики чем большее коричество раз мы убедимся в истинности какого-то утверждения, тем выше вероятность, что оно истинно в принципе всегда. Здесь речь идёт только о вероятностях, но вероятность может быть настолько большой, что часто такое утверждение можно принять за истинное с практической точки зрения.

Статистика как наука основывается на том факте, что изучаемых объектов всегда конечное число. Вспомним ворон из параграфа~\S1.6.5: мы знаем, что множество ворон конечно, и если мы увидим достаточно большое количество ворон, и все они окажутся чёрными, то вероятность того, что и оставшиеся вороны чёрные, довольно высока. Однако, это работает только для физических экспериментов, но не сработает с математическими утверждениями о числах, поскольку сколько бы много мы не рассмотрели примеров типа $2\times 3=3\times 2$, всегда остаётся ещё бесконечное число непроверенных вариантов, которые не позволяют делать нам никаких выводов. В случае с воронами мы рассматриваем какую-то долю от целого, а в случае натуральных чисел мы рассматриваем конечное число примеров против бесконечного числа вариантов. Чувствуете разницу?

Так вот. Примерно 50 лет тому назад было доказано, что то что я написал сейчас выше касательно неправоты обобщений конечного числа примеров на весь натуральный ряд~--- строго говоря не правда.

\begin{thm}
Для установления истинности почти любого утверждения $P(n)$ достаточно проверить лишь истинность конечного числа утверждений $P(n)$ для $n$ от 1 до некоторого $m$.
\end{thm}
\begin{proof}
Давайте представим себя на минуточку программистами, которые программируют на каком-то там языке программирования. Программа представляет собой некоторый текст конечной длинны, в которой написано по шагам что компьютер должен делать. Программы можно разделить на две категории: те, которые в какой-то момент сами собой прекратят свою работу, и программы, которые будут работать бесконечно долго. Это не очень правильно, но для удобства мы будем говорить, что такие программы <<зависают>>.

Поскольку алфавит, с помощую которого набирается текст программы, конечен, а так же конечна сама длина программы, то мы можем утверждать, что множество программ длины $n$ так же конечно. Тем более конечно подмножество программ длины $n$, которые в итоге прекращают своё выполнение вместо зависания. Среди всех этих программ существует такая программа, которая не зависает, но работает дольше всех других программ той же длины. Обозначим её время работы как $B_n$.

Как именно вычислить $B_n$ нам пока не понятно, но сама по себе функция $B:\mathbb{N}\to\mathbb{N}$, ставящая в соответствие длине программы максимальное время её выполнения, определена (эта функция по фольклорным причинам называется Busy Beaver Number, но это не важно).

Пусть у нас теперь есть некоторое математическое утверждение $P(n)$, которое мы можем для любого конкретного $n$ проверить на компьютере, написав программу. Раз мы можем написать программу, проверяющую $P(n)$ для любого заданного $n$, то мы можем написать и программу, которая будет проверять все $n$ подряд, начиная нулём, и которая остановится в тот момент, когда найдёт такое $M$, что $P(M)$ оказывается ложно. Сама эта программа, как и любая программа, будем иметь какую-то конечную длину $N$.

Запустим эту программу. Здесь возможно два итога: либо программа остановится раньше, чем за время $B(N)$ и мы опровергнем, что $P(n)$ истинно всегда, либо она не остановится вовсе, что значит, $P(n)$ истинно. Но у нас же есть число $B_N$! Запустив эту программу на выполнение, мы засекаем время. Если окажется, что программа работает больше, чем максимальное время $B_N$, за которое останавливается любая программа такой длины, то значит программа не останавливается и мы можем делать вывод об истинности $P(N)$.

Поскольку за время $B_N$ программа успеет проверить лишь конечное число утверждений $P(n)$, получается, что мы поконечному числу значений можем делать вывод об истинности $P$ для всех $n\in\mathbb{N}$. 
\end{proof}

Задумайтесь на секундочку: почти любой сложный вопрос математики, касающийся натуральных чисел, может быть установлен пём перебора конечного числа вариантов. Будь то теорема Ферма, гипотеза Гольдбаха, Коллатца\footnote{Гуглите} или что ещё: достаточно проверить конечное число случаев. Не знаю как вам, но на меня в своё время этот факт произвёл неизгладимое впечатление.

Насколько этот результат практичен? На самом деле совершенно не практичен. Во-первых, не понятно как вычислить значение $B_N$. Во-вторых, даже если мы его вычислим для какого-то большого $N$, то само $B_N$ наверняка окажется настолько гигантским, что само число вряд ли поместится в наш калькулятор. Так что выгоды мы из этого всего извлечь судя по всему не можем, увы. Но сам факт!

В формулировке теоремы фигурировала фраза <<почти любое утверждение $P$>>, что явно требует уточнения. Если внимательно читать доказательство, то мы увидим, что мы потребовали, чтобы для любого $n$ наша гипотеза могла быть проверена на компьютере. Если это невозможно, то мы как раз и получаем ситуацию, когда проверка конечного числа значений никогда не достаточна для доказательства утверждения для всего $\mathbb{N}$. Что это за утверждения $P$. которые даже в частном случае не могут быть проверены? Их не так много и мы не будем ими заниматься, ограничившись одним примером ниже.

Логично было бы, если бы после изложения этого результата я тут же показал бы, как считать числа $B_n$, однако сейчас мы уйдём в сторону и я покажу как их ещё можно использовать.

Попробуем написать такую программу, которая будет анализировать другую программу, и говорить нам о том, зависнет она или же нормально остановится. Можно рассматривать такую программу как функцию $H:P\to\{0,1\}$, где $P$~--- множество всех возможных программ. 0 означает, что программа зависнет, 1 что остановится.

При условии, что мы можем написать программу, вычисляющую $B_n$, мы нашу задачу можем очень легко решить. Пусть нам дана программа $x$ длины $n$, для которой надо установить остановится ли она. Поскольку программа~--- это просто описание каких-то действий, мы можем заставить выполнять эти действия не компьютер, а нашу программу $H$, то есть мы как бы будем симулировать выполнение программы $x$ внутри программы $H$. Это не сложно технически, но я не буду углубляться в детали как это реализуется, если вы знакомы с компьютерными технологиями, то наверняка слышали про интерпретаторы, виртуализацию, виртуальные машины и подобное. Это именно то, это возможно и это не особо сложно.

По ходу выполнения программы $x$, программа $H$ будет считать, как долго $x$ работает больше, чем время $B_n$, то мы знаем, что она не закончится, и $H$ останавливает $x$, а затем даёт нам результат 0. Если же $x$ остановится сама раньше, то $H$ даст рещультат 1. Вроде всё.

А теперь давайте напишем такую программу $A$, которая так же будет принимать на вход какую-то другую программу $x$, затем будет запускать на ней программу $H$, и если $H(x)=1$, то $A$ будет зависать (например, начнёт считать все натуральные числа подряд), а если же $H(x)=0$, то она будет возвращать какой-то результат. Такую программу так же легко написать.

Теперь давайте поймём какой результат мы получим, если на вход программе $A$ мы дадим её же саму, то есть попробуем выполнить $A(A)$. Что будет?

Предположим, что $H(A)=0$, тогда программа $A$ должна завершиться, вернув результат. Но это противоречит тому, что $H(A)=0$. Из этого противоречия видно, что $H(A)\not=0$. Пусть теперь $H(A)=1$, но тогда $A$ должна зависнуть, что противоречит тому, что $H(A)=1$, а значит $H(A)\not=1$. Как так? $H$ оказывается не равно ни одному своему значению!

Это противоречие означает, что программа $H$ не может быть написана, не существует такой программы и существовать не может. Но как так, ведь мы же чётко указали, как её можно написать! Если вглядеться, то при описании работы программы $H$ мы опирались на то, что мы можем как-то вычислить числа $B_n$, но мы не показывали этого. И это единственный момент во всём рассуждении, который мы не доказывали. Значит, числа $B_n$ вычислить невозможно.

Тот факт, что есть такая функция $B$, которая вполне определена, но которую невозможно вычислить, может показаться невероятным. На самом деле если подумать, то это довольно не сложно. Из определения функции $B$ мы могли бы попробовать вычислить $B(n)$, запустив одновременно все возможные программы длины $n$, и заведя таймер, пытаясь понять, какое самое большое время работы программы. Однако с учетом того, что есть программы, которые зависают, мы никогда не узнаем, когда таймер пора выключать, хотя конечно же такой момент во времени существует. Это и есть пример того, что  невозможно вычислить.

Мы получили два результата.

\begin{thm}
Невозможно написать программу, которая бы могла по коду другой программы определить остановится ли она или зависнет.
\end{thm}
\begin{thm}
Числа $B_n$ невычислимы. Другими словами невозможно определить максимальное время, которое может работать независающая программа длины $n$.
\end{thm}

Приведённые рассуждения можно вывернуть ещё и вот под каким углом. Напишем программу $E$, которая будет проверять истинность произвольного утверждения $x$ путём последовательного перебора всех возможных доказательств (программа может начинать с коротких доказательств и постепенно переходить к более длинным, так что такая программа определённо может быть написана). Если предположить, что всё можно доказать или опровергнуть, то через какое-то время наша программа либо найдёт доказательство для $x$, либо доказательство для $\neg x$.

Используя эту программу, однако, мы опять же легко можем написать пресловутую программу $H$ проверяющую, остановится ли программа $y$ или нет. Просто вместо запуска программы $y$ и ожидания времени $B_n$ мы на этот раз будем искать доказательство остановки или зависания $y$. Поскольку мы уже знаем, что программа $H$ не может существовать, наше предположение, что программа $E$ всегда либо найдёт доказательство $x$ либо $\neg x$ так же не верно. Это значит, что существуют такие утверждения $x$, которые невозможно ни доказать ни опровергнуть. Как вы вероятно помните, это есть ни что иное как теорема Гёделя о неполноте.

\begin{thm}
Существуют утверждения, которые невозможно ни доказать, ни опровергнуть.
\end{thm}
\begin{proof}
В принципе выше мы уже доказали эту теорему, но я приведу ещё одно рассуждение.

Для начала мы сделаем набросок доказательства, опускающий ряд технических деталей, чтобы была просто понятная идея. Эти технические детали читатель сможет при желании восстановить самостоятельно.

Во-первых заметим, что каждую формулу и каждое доказательство можно каким-то образом пронумеровать. Например, закодировав таким образом, как было показано в \S3.2. Номер формулы  будем обозначать символом $g$, а номер доказательства символом $G$. Эти номера мы будем называть {\slshape гёделевскими номерами}. Так же предположим, что мы можем каким-то образом записать формулу $pf(x, y)$, которая обращается в истину тогда и только тогда, когда $x$ является номером доказательства для формулы под номером $y$ (это более сложное утверждение, но в принципе существование такой формулы читатель может доказать самостоятельно в качестве относительно сложного упражнения).

Идея доказательства  сводится к формулированию такого предложения теории, которое каким-то образом ссылалось бы само на себя. В общих чертах это делается таким образом: если рассмотреть формулу $F(x)$, имеющую одну свободную переменную, то для неё существует некоторый номер $n=g(F)$. Тогда формула $F(n)$ будет косвенно ссылаться на саму себя. Наша задача сейчас сводится к тому, чтобы сформулировать $F(x)$ таким образом, чтобы она заключала в себе утверждение о доказуемости формулы с номером $x$ (вспомните теорему из первой главы «эту теорему невозможно доказать» — мы сейчас как раз занимаемся построением такой теоремы).

Чтобы получить в теореме ссылку на саму себя, определим формулу $q(x, g(F)) = \neg pf(x, g(F(g(F))))$. То есть если словами, то $q(x, g(F))$, означает, что $x$ не является номером доказательства для $F(g(F))$. Последнее как раз и содержит утверждение, ссылающееся само на себя. Сама форма $q(x, y)$ преобразовывает $y$ (некоторый номер) в номер формулы со ссылкой на себя и обращается в истину только тогда, когда $x$ не является доказательством для полученной формулы. Такую формулу не сложно сформулировать, воспользовавшись опять же кодированием в позиционной системе счисления (\S3.2).

Теперь мы можем рассмотреть такую формулу: $P(x) = \forall y q(y, x)$. Она, во-первых, имеет некоторый номер $g(P)$, во-вторых имеет свободную переменную $x$, и в третьих содержит утверждение о недоказуемости $x$, преобразованного в формулу, ссылающуюся на саму себя. Тогда если мы подставим вместо $x$ номер $g(P)$, то получим $P(g(P))$, а это то что нам и требовалось.

Действительно, предположим, что $P(g(P))$ доказуемо. По определению это означает, что $\forall y q(y, g(P))$ и то есть $P(g(P))$ не может быть доказано. Противоречие.

Предположим обратное. Пусть доказуемо отрицание $\neg P(g(P))$. Это значит, что $\exists y \neg q(y, g(P))$, то есть существует доказательство $P(g(P))$, и последнее должно быть истинно. Опять же противоречие.

Мы получили, что ни предложение $P(g(P))$ ни $\neg P(g(P))$ действительно не могут быть доказаны, а это и есть утверждение о неполноте.
\end{proof}

Можно показать набросок и второй теоремы Гёделя о неполноте (несколько с изуродованной формулировкой).

\begin{thm}
Если аксиоматика Цермело-Френкеля непротиворечива, то это невозможно доказать.
\end{thm}
\begin{proof}
Привети строгое доказательство мы не сможем, лишь набросок. Если ZF непротиворечива, то по прошлой теореме верно, что существует некая недоказуемая теорема $g$. Обозначим непротиворечивость за $Con$.
\end{proof}